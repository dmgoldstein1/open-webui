/*
Generated by GitHub Copilot (OpenAI model)
Description: Unit test for synchronous chat path using stubbed vLLM and Ollama HTTP servers. Verifies DDB persistence and response shape.
*/

const http = require('http');
const { DynamoDBClient, CreateTableCommand, DescribeTableCommand } = require('@aws-sdk/client-dynamodb');
const { GetCommand } = require('@aws-sdk/lib-dynamodb');

async function ensureTable(ddb, tableName) {
  try { await ddb.send(new DescribeTableCommand({ TableName: tableName })); return; } catch (_) {}
  await ddb.send(new CreateTableCommand({
    TableName: tableName,
    BillingMode: 'PAY_PER_REQUEST',
    AttributeDefinitions: [{ AttributeName: 'conversation_id', AttributeType: 'S' }],
    KeySchema: [{ AttributeName: 'conversation_id', KeyType: 'HASH' }],
  }));
}

function startStubServer(port, replyText) {
  return new Promise(resolve => {
    const server = http.createServer((req, res) => {
      if (req.method === 'POST' && req.url && req.url.includes('/v1/chat/completions')) {
        let body = '';
        req.on('data', chunk => body += chunk);
        req.on('end', () => {
          const resp = { id: 'x', object: 'chat.completion', created: Date.now()/1000|0, model: 'stub', choices: [{ index: 0, message: { role: 'assistant', content: replyText }, finish_reason: 'stop' }], usage: { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 } };
          res.writeHead(200, { 'content-type': 'application/json' });
          res.end(JSON.stringify(resp));
        });
      } else { res.writeHead(404); res.end(); }
    });
    server.listen(port, () => resolve(server));
  });
}

async function run() {
  process.env.AWS_REGION = process.env.AWS_REGION || 'us-east-1';
  process.env.AWS_ACCESS_KEY_ID = process.env.AWS_ACCESS_KEY_ID || 'test';
  process.env.AWS_SECRET_ACCESS_KEY = process.env.AWS_SECRET_ACCESS_KEY || 'test';
  process.env.DYNAMODB_ENDPOINT_URL = process.env.DYNAMODB_ENDPOINT_URL || 'http://localhost:8000';
  process.env.DDB_TABLE = process.env.DDB_TABLE || 'Conversations';

  const vllm = await startStubServer(9091, 'vllm-ok');
  const ollama = await startStubServer(9092, 'ollama-ok');
  process.env.VLLM_BASE_URL = 'http://127.0.0.1:9091';
  process.env.OLLAMA_OPENAI_BASE_URL = 'http://127.0.0.1:9092';

  const ddb = new DynamoDBClient({ region: process.env.AWS_REGION, endpoint: process.env.DYNAMODB_ENDPOINT_URL, credentials: { accessKeyId: 'test', secretAccessKey: 'test' } });
  await ensureTable(ddb, process.env.DDB_TABLE);

  const { handler } = require('../src/middleware/handler');

  // Text-only -> vLLM
  const e1 = { version: '2.0', requestContext: { http: { method: 'POST', path: '/chat/sync' } }, rawPath: '/chat/sync', body: JSON.stringify({ conversation_id: 'conv-sync-1', user_message: 'hello' }) };
  const r1 = await handler(e1);
  if (r1.statusCode !== 200) { console.error('FAIL: sync status', r1.statusCode, r1.body); process.exit(1); }
  const body1 = JSON.parse(r1.body);
  if (body1.choices?.[0]?.message?.content !== 'vllm-ok') { console.error('FAIL: vllm reply mismatch'); process.exit(1); }

  // With an image -> Ollama
  const e2 = { version: '2.0', requestContext: { http: { method: 'POST', path: '/chat/sync' } }, rawPath: '/chat/sync', body: JSON.stringify({ conversation_id: 'conv-sync-1', user_message: 'caption', images: [{ image_url: 'http://x/cat.png' }] }) };
  const r2 = await handler(e2);
  const body2 = JSON.parse(r2.body);
  if (body2.choices?.[0]?.message?.content !== 'ollama-ok') { console.error('FAIL: ollama reply mismatch'); process.exit(1); }

  // Verify DDB now has 4 messages (2 interactions)
  const doc = require('../src/shared/aws').createDynamoDocClient();
  const out = await doc.send(new GetCommand({ TableName: process.env.DDB_TABLE, Key: { conversation_id: 'conv-sync-1' } }));
  if (!out.Item || !Array.isArray(out.Item.messages) || out.Item.messages.length < 2) {
    console.error('FAIL: DDB did not persist messages'); process.exit(1);
  }

  vllm.close();
  ollama.close();
  console.log('PASS: chat sync path with stubs');
}

run().catch(err => { console.error('FAIL:', err.message); process.exit(1); });
