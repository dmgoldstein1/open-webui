/*
Generated by GitHub Copilot (OpenAI model)
Description: Lambda-style HTTP API handler. Receives chat requests, fetches history from DynamoDB, decides routing, and enqueues jobs to SQS. Also serves conversation fetch and health endpoints.
Context: Attach to API Gateway in prod; for local dev, wrapped by Express in src/local/server.js.
*/

const { SendMessageCommand } = require('@aws-sdk/client-sqs');
const { createSqsClient } = require('../shared/aws');
const { getConversation } = require('../shared/historyStore');
const { decideRoute } = require('../shared/routing');

const sqs = createSqsClient();
const DEFAULT_HEADERS = {
  'Access-Control-Allow-Origin': process.env.ALLOW_ORIGIN || '*',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
  'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',
  'Content-Type': 'application/json',
};

function makeResponse(statusCode, body) {
  return { statusCode, headers: DEFAULT_HEADERS, body: JSON.stringify(body) };
}

async function postChat(body) {
  const { conversation_id, user_message, images, priority } = body || {};
  if (!conversation_id || typeof user_message !== 'string') {
    return makeResponse(400, { error: 'conversation_id and user_message are required' });
  }
  const history = await getConversation(conversation_id);
  const route = decideRoute({ user_message, images });
  const queueUrl = (priority === 'high')
    ? (process.env.SQS_PRIORITY_QUEUE_URL || process.env.SQS_QUEUE_URL)
    : (process.env.SQS_QUEUE_URL);
  if (!queueUrl) return makeResponse(500, { error: 'SQS queue URL not configured' });

  const job = {
    type: 'chat',
    conversation_id,
    user_message,
    images: images || [],
    history: history.messages || [],
    route,
    enqueued_at: new Date().toISOString(),
  };

  await sqs.send(new SendMessageCommand({
    QueueUrl: queueUrl,
    MessageBody: JSON.stringify(job),
  }));

  return makeResponse(202, { status: 'enqueued', route });
}

async function getConversationById(query) {
  const id = (query && (query.conversation_id || query.id)) || null;
  if (!id) return makeResponse(400, { error: 'conversation_id required' });
  const item = await getConversation(id);
  return makeResponse(200, { conversation: item });
}

async function health() {
  return makeResponse(200, { status: 'ok', time: new Date().toISOString() });
}

// AWS Lambda handler signature for API Gateway v2 HTTP
async function handler(event) {
  const method = (event.requestContext && event.requestContext.http && event.requestContext.http.method) || event.httpMethod || 'GET';
  const path = (event.requestContext && event.requestContext.http && event.requestContext.http.path) || event.rawPath || event.path || '/';

  if (method === 'OPTIONS') return makeResponse(204, {});

  try {
    if (method === 'POST' && path.endsWith('/chat')) {
      const body = typeof event.body === 'string' ? JSON.parse(event.body || '{}') : (event.body || {});
      return await postChat(body);
    }
    if (method === 'GET' && path.endsWith('/conversation')) {
      const query = event.queryStringParameters || {};
      return await getConversationById(query);
    }
    if (method === 'GET' && path.endsWith('/health')) {
      return await health();
    }
    return makeResponse(404, { error: 'Not found' });
  } catch (err) {
    return makeResponse(500, { error: err.message || 'Internal error' });
  }
}

module.exports = { handler };
